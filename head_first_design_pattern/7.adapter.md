<!-- markdownlint-disable MD013-->

# The Adapter and Facade Patterns

We all know what kind of adapters we have in real life: power adapters, cable adapters, USB adapter,... In short, those adapters sit between the interface of one end and make it pluggable, compatible to another end. They can be very simple, like changing the shape of the plug so that it matches the outlet, or complex like changing the power level so that they match.

The idea of a OO adapter is the same: when a vendor class doesn't share the same interface as your current existing system, if you want to plug that vendor class in, you'll need a adapter class to stand between the 2. With this, you can:

- Avoid modifying you old code
- Create as many adapter needed for as many vendors as you need

## Adapter pattern defined

> The Adapter Pattern converts the interface of a class into another interface the client expect. Adapter lets classes work together that couldn't otherwise because of incompatible interfaces.

Since the idea and example of this pattern is pretty clear-cut let's go into details

```mermaid
classDiagram
    class Client
    note for Client "The Client is implemented \nagainst the Target interface."

    class Target {
        <<interface>>
        +request()*
    }
    note for Target "The interface the \nClient expects to see."

    class Adapter {
        -Adaptee adaptee
        +request()
    }
    note for Adapter "The Adapter implements the \nTarget interface and holds an \ninstance of the Adaptee."

    class Adaptee {
        +specificRequest()
    }
    note for Adaptee "The existing interface that \nneeds adapting."

    Client --> Target : uses
    Target <|.. Adapter : implements
    Adapter --> Adaptee : delegates to
```

## Object and class adapters

2 kind of adapter:

- object
- class

The 1 we draw above is an object adapter, which means they make use of composition to adapt the client request to the adaptee's object they hold. The class version will not use composition, but will inherit the Adaptee's class while also inherit the target class, making it a multi-inheritance situation

```mermaid
classDiagram
    class Client
    note for Client "The Client is implemented \nagainst the Target."

    class Target {
        +request()
    }
    note for Target "The Target is a class, \nnot an interface."

    class Adaptee {
        +specificRequest()
    }
    note for Adaptee "The class being adapted."

    class Adapter {
        +request()
    }
    note for Adapter "The Adapter inherits from \nboth Target and Adaptee."

    Client --> Target : uses
    Target <|-- Adapter : extends (Inheritance)
    Adaptee <|-- Adapter : extends (Inheritance)
```

## Comparison

| feature      | object adapter                | class adapter                    |
| ------------ | ----------------------------- | -------------------------------- |
| relationship | has-a                         | is-a                             |
| behaviour    | only adds/translate behaviour | can override adaptee's behaviour |
| Object count | two objects                   | 1 object                         |
