<!-- markdownlint-disable MD013-->

# Singleton Pattern

The idea of this pattern is pretty common and easy to understand; therefore the book doesn't really have a problem or scenario to mental map the pattern to a concrete use case.
Some note:

- There're a lot of objects we only need one of: thread pools, caches, dialog boxes,... In fact, in some cases it would cause unpredictable behavior if there are more than 1 object existing at the same time
- Singleton pattern is a convention for ensuring existence of only 1 object for a given class; it gives us a global point access but without all the downside of global variables
- The implementation can be encapsulate inside the singleton class itself:

```java
public class Singleton {
  private static Singleton uniqueInstance;

  // private constructor
  private Singleton() {}

  public static Singleton getInstance() {
    if (uniqueInstance == null) {
      return new Singleton();
    }
    return uniqueInstance;
  }

  // other stuff
}

```

## Singleton defined

> The singleton pattern ensures a class has only one instance, and provides a global point of access to it

- We are taking a class and letting it manage a single unique instance of itself. We're also preventing any other class from creating a new instance of it
- We provide a global access point to this instance: whenever you need an instance, just query the class `getInstance()`

Since we have already seen both the textbook definition and the implementation, there's not much to talk about here. Let's look at some of the problem with that we might encounter down the line with this pattern

## Dealing with multi-threading

Sometimes we're forced to work with threads. The classic singleton can be unsuitable for that when multiple threads call `getInstance` which will lazily instantiate the object this can threads holding different object (which is not unique anymore).

There are a few ways to fix this:

- If `getInstance` doesn't really affect performance, we can make the method synchronized. In java this can be done pretty easily with the `synchronized` keyword, meaning that when this method is invoked, it can't be invoke again in other threads until the invocation is returned
- You can eagerly create the unique instance instead of instantiate it lazily
- We can use double-check locking which ensures that the first time the instance is created it's always synchronized

```java
public class Singleton {
  private volatile static Singleton uniqueInstance;
  private Singleton() {}
    public static Singleton getInstance() {
      if (uniqueInstance == null) {
        // if its null, enter synchronized block and check again
        // only for the first time
        synchronized (Singleton.class) {
          if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
          }
        }
      }
    return uniqueInstance;
  }
}

```
