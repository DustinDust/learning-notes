<!-- markdownlint-disable MD013-->

# The Factory Method Pattern

## The problem

We've been learning about good OO - and 1 of the things that's mentioned the most is 'program interface, not implementation'.

The issue with Java (and other programming language) is that the only way to create new object is through the constructor method. It's not particularly wrong per-se; it's just kind of violating the rule above

> When you use the **new** operator you are certainly instantiating a concrete class which is an implementation and not an interface

Example:

```java
Pizza pizza;

if (isNewYork) {
  pizza = new NewYorkPizza();
} else if (isItaly) {
  pizza = new ItalianPizza();
} else {
  pizza = new InstantPizza(); // ew
}
```

As our design should be open for extension but closed for modification, code snippets such as above should not exist, as they require modification as soon as `NewYorkPizza` or `ItalianPizza` classes change;

Let's apply the same steps~ by identify the aspects that vary and separate them from what stays the same.

## Encapsulating object creation

And move it into another object that is only going to be concerned with creating pizzas. This object is a `Factory` object.

Factories handle the detail of object creation. Once we have a `PizzaFactory`, other place in the codebase can ask the factory to make 1 for them.

```java
class SimplePizzaFactory {
  public Pizza createPizza(String type) {
    Pizza pizza = null;

    if (type.equals("cheese")) {
      pizza = new CheesePizza();
    } else if() {
      // more here
    }
    return pizza;
  }
}
```

While this may look pointless (as we just moved the constructor call from 1 place to another place) but we can actually override the `createPizza` method and change the pizza type being created, while maintaining the overall interface.

This will helps alot when you want to franchise your pizza since we can delegate the pizza creation to each individual store.

Another thing nice about this pattern is that its allow for composition which means runtime change during behavior without having to make changes to code.

```mermaid
classDiagram
    %% The Creator Classes
    class PizzaStore {
        <<Abstract>>
        +orderPizza(String type) Pizza
        #createPizza(String type)* Pizza
    }

    class NYPizzaStore {
        #createPizza(String type) Pizza
    }

    class ChicagoPizzaStore {
        #createPizza(String type) Pizza
    }

    %% The Product Classes
    class Pizza {
        <<Abstract>>
        +String name
        +String dough
        +String sauce
        +ArrayList toppings
        +prepare()
        +bake()
        +cut()
        +box()
        +getName()
    }

    class NYStyleCheesePizza {
        +constructor()
    }
    class NYStyleClamPizza {
        +constructor()
    }

    class ChicagoStyleCheesePizza {
        +constructor()
        +cut()
    }
    class ChicagoStyleClamPizza {
        +constructor()
    }

    %% Relationships
    %% Inheritance (IS-A)
    PizzaStore <|-- NYPizzaStore : Extends
    PizzaStore <|-- ChicagoPizzaStore : Extends
    Pizza <|-- NYStyleCheesePizza : Extends
    Pizza <|-- NYStyleClamPizza : Extends
    Pizza <|-- ChicagoStyleCheesePizza : Extends
    Pizza <|-- ChicagoStyleClamPizza : Extends

    %% Dependency (Creates)
    %% The Concrete Creator creates the Concrete Product
    NYPizzaStore ..> NYStyleCheesePizza : Creates
    NYPizzaStore ..> NYStyleClamPizza : Creates
    ChicagoPizzaStore ..> ChicagoStyleCheesePizza : Creates
    ChicagoPizzaStore ..> ChicagoStyleClamPizza : Creates
```

## Meet the Factory method pattern

Factory method patterns encapsulates object creation by letting subclasses decide what object to create. It defines an interface for creating an object, but lets subclasses decide which class to instantiate.

The structure consist of:

- Creator: abstract class the define factory method that subclasses implement to produce product
- Product: declares the interface, which is common to all objects that can be produced by the creator and its subclasses.
- Concrete Creator: override the base factory method to return the object. The object can be created or retrieved from existing cache, object pool or another source.
- Concrete Product: implementation of product interface

You can see the example [here](./examples/factoryPattern.java)

## Revisit our pizza store

Currently we have our `createPizza` method to receive a parameter called item.

```java

proctected createPizza(String item) {
  // do stuff
}
```

Seems simple enough, but when the amount of customization to the pizza creation increases such as more toppings, more sauce type, maybe option to create half a pizza of 1 type and the other half of another type...and on top of that, we need to ensure they are compatible; Soon it will overload our `createPizza` method with entangle if-else's

This is when the `Abstract Factory Pattern` comes in to rescue.

## Meet the Abstract Factory Pattern

> The Abstract Factory Pattern provides an interface for creating families of related or dependent objects without specifying their concrete class

In our pizza case, we can say `Sauce`, `Box`, `Dough`, `Toppings` all belong to part of the product `Pizza`

We will create the abstract factory, which is an interface with a list of creation methods for all products that are part of the product family, for example: `createSauce`, `createBox`,... These methods must return abstract product types like `Sauce` represented by the interface instead of concrete class

```mermaid
classDiagram
    class PizzaFactory {
        <<interface>>
        +createSauce() Sauce
        +createBox() Box
        +createDough() Dough
        +createTopping() Topping
    }

    class NYStyleClamPizzaFactory {
        +createSauce() Sauce
        +createBox() Box
        +createDough() Dough
        +createTopping() Topping
    }

    class ChicagoStyleCheesePizzaFactory {
        +createSauce() Sauce
        +createBox() Box
        +createDough() Dough
        +createTopping() Topping
    }

    PizzaFactory <|.. NYStyleClamPizzaFactory : Realizes
    PizzaFactory <|.. ChicagoStyleCheesePizzaFactory: Realizes

    note for ChicagoStyleCheesePizzaFactory "Produces Chicago Cheese pizza variants"
    note for NYStyleClamPizzaFactory "Produces NewYork Clam pizza variants"
```

For each variants for a pizza, we create a separate factory class based on the `AbstractFactory` and this class will override and implements the creation methods to their desire while allow for a more dynamic, flexible and unified usage of the class so that nothing will break when, for example, the `ChicagoStyleCheesePizza` changes their sauce or boxes.

### Structure

1. Abstract Products: interfaces for set of distinct but related products (sauce, box, toppings, dough, ...) which make up a product family (pizza)
2. Concrete products: various implementations of abstract products, grouped by variants (`PaperBox`, `ChiliSauce`, `TomatoTopping`,...)
3. The Abstract Factory interface declares a set of methods for creating each of the abstract products.
4. Concrete Factories implement creation methods of the abstract, each of these corresponds to a specific variant of products and creates only those product variants
