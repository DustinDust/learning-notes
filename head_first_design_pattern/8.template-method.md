<!-- markdownlint-disable MD013-->

# The template method pattern

## The problem

The Starbuzz coffee shop has a recipe for coffee, tea and other drinks. For example, this is the code for preparing coffee

```java
void prepareCoffe() {
  boilWater();
  brewCoffeeGrinds();
  pourInCup();
  addSugarAndMilk();
}
```

Turns out, the recipe for tea is quite the same

```java
void prepareRecipe() {
  boilWater();
  steepTeaBag();
  pourInCup();
  addLemon();
}
```

This seems quite a case of code duplication. The first idea for this is that we should abstract the commonality into a base class for `Tea` and `Coffee`.

```java
class CaffeineBeverage {
  prepareRecipe()
  boilWater()
  pourInCup()
}
```

This seems valid, but we can still abstract more. The original recipes of tea and coffee more or less follows the same steps. Lets go a head and modify the beverage class

```java
abstract class CaffeineBeverage {
  void final prepareRecipe() {
    boilWater();
    brew();
    pourInCup();
    addCondiments();
  }
  void boilWater() {} // implementation
  void pourInCup() {} // implementation
  abstract void brew();
  abstract void addCondiments();
}
```

Now, the sub-classes can override the method `brew` and `addCOndiments` to make their recipe

## Meet the template method pattern

> The Template Method pattern defines the skeleton of an algorithm in a method, deferring some steps to sub-classes. Template method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure

Pros:

- Let clients override only certain parts of a large algorithm, making them less affected by changes that happen to other parts of the algorithm
- Pull the duplicate code into a superclass -> less code duplication

### Hooks

Hooks are methods that are declared in the abstract class but with default or empty implementation, which allow the subclasses to hook into the algorithm at various point and modify the algorithm in certain way. They can also ignore it completely.

Example:

```java
// abstract class CaffeineBeverageWithHooks
final void prepareRecipe() {
  boilWater();
  brew();
  //here we use the hook to add condiments conditionally
  if(customerWantsCondiments()) {
    addCondiments();
  }
}

// other declaration
boolean customerWantsCondiments() {
  return true;
}
```

In the subclass, we can override the hook method

```java
// class Tea extends CaffeineBeverageWithHooks
public boolean customerWantsCondiments() {
  String answer = getUserInput();
  if(answer.toLowerCase().startsWith("y")) {
    return true;
  } else {
    return false;
  }
}
```

All of the sudden we can allow subclass to control whether or condiments are added using their own logic. This leads us into a new design principle. `The Holly Principle` (kind of like inversion of control).
